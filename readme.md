# Django_331 - Учебный проект "Карточки интервального повторения"
## Lesson 48

### Создание проекта Django_331

1. Создали репозиторий
2. Создали проект Django_331
3. Установили зависимости `pip install django==4.2`
4. Сохранили зависимости в файл `requirements.txt` командой `pip freeze > requirements.txt`

Развернуть проект на локальной машине:
 - Склонировать репозиторий командой `git clone
 - Перейти в папку проекта `cd Django_331`
 - Создать виртуальное окружение `python -m venv venv`
 - Активировать виртуальное окружение `source venv/bin/activate`
 - Установить зависимости `pip install -r requirements.txt`

### Создание Django project

1. Создать проект `django-admin startproject anki .`
Этой командой мы создадим проект с именем `anki` в текущей директории.
Точка в конце команды означает, что проект будет создан в текущей директории, 
без создания дополнительной директории с именем проекта.

2. Запуск проекта `python manage.py runserver`
Для запуска проекта, вам нужно использовать терминал, и находясь в директории проекта, на одном уровне с файлом `manage.py`, выполнить команду `python manage.py runserver`
Для остановки сервера используйте комбинацию клавиш `Ctrl+C`

**Команды терминала:**
- `python manage.py runserver` - запуск сервера
- `cd` - смена директории
- `cd..` - переход на уровень выше
- `ls` - просмотр содержимого директории
- `pwd` - показать текущую директорию

3. Создание приложения `python manage.py startapp cards`
После создания приложения, вам нужно зарегистрировать его в файле `settings.py` в разделе `INSTALLED_APPS`
Без этого, полноценно, приложение не будет работать.

### Создали первое представление

```python
from django.http import HttpResponse

def main(request):
    return HttpResponse("Привет, мир!")  # вернет страничку с надписью "Привет, мир!" на русском языке.

```

Чтобы представление заработало, его нужно зарегистрировать в файле `urls.py` конфигурации проекта.

### Создали первый URL

```python
path('', views.main),
```

Теперь, если вы перейдете на главную страницу сайта, то увидите надпись "Привет, мир!"

### Создаем детальное представление карточки по ее ID

Для этого нам нужно создать новый маршрут, с конвертом int, который будет принимать ID карточки.

```python
path('cards/<int:card_id>/', views.card_detail),
```

А так же функцию, которая будет обрабатывать запрос и возвращать страницу с детальной информацией о карточке.

```python
def card_by_id(request, card_id):
    return HttpResponse(f"Карточка с ID {card_id}")
```

### `include` и собственный файл `urls.py` для приложения `cards`

1. Создали еще одно представление `get_all_cards` в файле `views.py`
2. Создали файл `urls.py` в директории приложения `cards`
3. Зарегистрировали новый файл `urls.py` в файле `urls.py` конфигурации проекта с помощью функции `include`
4. Зарегистрировали маршруты без префикса `cards/` в файле `urls.py` приложения `cards`
5. Удалили маршруты `cards/` из файла `urls.py` конфигурации проекта

## Lesson 49

### Настройка конфигурации запуска в PyCharm

1. **Откройте "Edit Configurations"**: В PyCharm перейдите в меню "Run" -> "Edit Configurations" для настройки новой конфигурации запуска.
2. **Добавление новой конфигурации**: Нажмите на плюсик (+) и выберите тип конфигурации для Python.
3. **Заполнение полей конфигурации**:
   - **Название**: Дайте конфигурации понятное имя, чтобы вы могли легко идентифицировать её среди других конфигураций.
   - **Рабочая директория**: Укажите директорию вашего проекта Django. Это папка, где находится файл `manage.py`.
   - **Интерпретатор языка**: Выберите интерпретатор Python для вашего виртуального окружения, если вы его используете, или глобальный интерпретатор, если виртуальное окружение не настроено.
   - **Script path**: Укажите путь к файлу `manage.py` в вашем проекте Django.
   - **Параметры**: Введите `runserver`, чтобы запустить разработческий сервер Django.


### Знакомство с Django Templates (Шаблоны)

1. Создали папку `templates` в директории приложения `cards`
2. Создали файл `catalog.html` в директории `templates/cards`
3. Переписали функцию `get_all_cards` в файле `views.py` так, чтобы она возвращала страницу `catalog.html`
используя функцию `render` из модуля `django.shortcuts`

**commit: `lesson_49: рендер первого шаблона`**

### Работа с шаблоном 
1. Создали словарь с данными в `views.py` и передали его в шаблон
```python
info = {
    "users_count": 100600,
    "cards_count": 100600,
}
```
2. Вставили данные в шаблон `catalog.html` с помощью шаблонного языка Django
3. Подключили BS5 по CDN и стилизовали страницу

**commit: `lesson_49: передал первые данные в шаблон и подключил BS5`**

### Смотрим типы данных внутри шаблона
- Проверили, что можем передать экземпляр класса, и вывести его атрибуты в шаблоне
- Проверили, что можно передать только словарь
- Передали список и вывели его в шаблоне
- Передали список меню и познакомились с конструкцией `{% for item in menu %}`

**commit: `lesson_49: первый цикл в шаблоне`**

### Посмотрели на тег шаблона `if`
- Сделали `<hr>` после каждого элемента списка, кроме последнего

**commit: `lesson_49: первый тег if в шаблоне`**

### Сделали ссылки в меню кликабельными
- Передали в шаблон список словарей, где каждый словарь содержит url и title
- Осталось протестировать шаблонный тег `url`!


**commit: `lesson_49: сделал ссылки в меню кликабельными`**


## Lesson 50

### Как получить успешное прохождение тестов из ДЗ №29
Что в urlpatterns нужно писать, чтобы получлся путь типа '/cards/catalog/1/'? Как пройти тест?

Делаем разбор ДЗ
Определили, что важнейшую роль играет порядок подключения URL-маршрутов в файле `urls.py`,
отрабатывает первый попавшийся маршрут.

Если первый `slug` - то он отработает число.
Если первый `int` - то он НЕ будет отрабатывать строку.

**commit: `hw_29: пофиксили urls.py (порядок имеет значение) и прошли тесты`**

### Изменение структуры `cards/url.py` и `cards/views.py`
Изменил пути и функции для дальнейшего развития проекта.

### Создание базового шаблона `base.html` в корне проекта в папке `templates`
- Создали базовый шаблон `base.html` в папке `templates`
- Указали кастомный, нестандартный путь для Джанго в файле `settings.py` в разделе `TEMPLATES` 
- Прописали там `BASE_DIR / 'templates',`
- Подключили базовый шаблон для теста функции `main` в файле `views.py`

**commit: `lesson_50: создал базовый шаблон base.html`**

### Синтаксис блоков в шаблонах. `{% block %}` и `{% extends %}`

- Описали блок `content` в базовом шаблоне `base.html`
- Создали шаблон `main.html` в папке `templates`, который расширяет базовый шаблон через `{% extends %}`
- Переопределили блок `content` в шаблоне `main.html` через `{% block %}`
- Подключили шаблон `main.html` в функции `main` в файле `views.py`

**commit: `lesson_50: создал шаблон main.html и расширил базовый шаблон`**

### Создание шаблона `nav_menu.html` и подключение его в базовом шаблоне через `{% include %}`
- Создали каталог `includes` в папке `templates` в корне проекта
- Создали шаблон `nav_menu.html` в папке `includes`
- Написли навигационное меню в шаблоне `nav_menu.html`
- Использовали шаблонный тег `{% url %}` который позволяет создавать ссылки на страницы по их именам в файле `urls.py`
- Подключили шаблон `nav_menu.html` в базовом шаблоне `base.html` через `{% include %}`
- Добавили датасет с карточками и меню, чтобы проверить работу шаблона

**commit: `lesson_50: создал шаблон nav_menu.html и подключил его в базовом шаблоне`**

### Работа с шаблонами `about.html`, `catalog.html`, `main.html` а так же модификация `views.py`
- Модифицировали все шаблоны, и сделали так, чтобы они наследовались от базового шаблона
- Модфицировали соответствующие функции в файле `views.py`, чтобы они возвращали нужные шаблоны и принимали данные для меню
- Наладили рендер меню во всех шаблонах, и получили "сквозное" меню на всех страницах

**commit: `lesson_50: модифицировал все шаблоны и функции в views.py - сквозная навигация`**


### Начали работу над каталогом карточек (динамическая вставка данных в шаблон, цикл + `include`)
- Создали `includes` в папке `templates` в приложении `cards`
- Внутри создали шаблон `card_preview.html`
- Шаблон `card_preview.html` принимает на вход словарь с данными о карточке и возвращает карточку,
которая будет вставлена в каталог карточек в шаблоне `catalog.html` в цикле  #TODO: ДОДЕЛАТЬ!)

**commit: `lesson_50: начал работу над каталогом карточек и динамической вставкой данных в шаблон`**

## Lesson 51

### Продолжили работу над каталогом карточек (динамическая вставка данных в шаблон, цикл + `include`)
- Добавили отсутствующий маршрут в файл `urls.py` приложения `cards` (детальное отображение карточки по ID)
- Добавили шаблон `card_detail.html` в папке `templates/cards` 
- Доделали `include` в шаблоне `catalog.html` и вставили в него карточки из словаря
- Обновили функцию `get_detail_card_by_id` - сделали поиск карточки по ID в словаре и возврат шаблона `card_detail.html` ИЛИ 404


**commit: `lesson_51: доделал каталог карточек и детальное отображение карточки по ID`**

### Собственные шаблонные теги через `simple_tag` 
- Создали тег шаблона `markdown_to_html` через `simple_tag` в файле `cards/templatetags/markdown_to_html.py`
- Протестировали его в представлении `card_detail` в шаблоне `card_detail.html`

**commit: `lesson_51: создал собственный тег шаблона markdown_to_html через simple_tag`**
### Фильтры в шаблонах

### Создали папку `static` в приложении `cards` и подключили статику в шаблоне `base.html`
- Создали папку `static` в приложении `cards`
- Создали папку `cards` в папке `static`
- В ней создали папку `css` и файл `main.css`, а так же папку `js` и файл `main.js`
- Создали тестовые стили и скрипт
- Подключили статику в шаблоне `base.html` через тег `{% load static %}` и тег `{% static %}`
- Подключили стили и скрипт в шаблоне `base.html`
- Проверили работу статики на всех страницах


**commit: `lesson_51: подключил статику в шаблоне base.html`**

### Работа с фильтрами в шаблонах
Посмотрели на работу следующих фильтров в шаблоне `card_preview.html`:
- `length`
- `truncatechars`
- `join`

Так же, в шаблон был добавлен цикл для вывода тегов карточки.

**commit: `lesson_51: работа с фильтрами в шаблонах`**

### Сделаем второй вариант шаблонного тега `markdown_to_html` через `inclusion_tag`
- Создали второй вариант шаблонного тега `markdown_to_html` через `inclusion_tag` в файле `cards/templatetags/markdown_to_html.py`
- Создали шаблон `markdown_to_html.html` в папке `templates/cards`
- Протестировали его в представлении `card_detail` в шаблоне `card_detail.html`
- Сравнили работу двух вариантов шаблонного тега

## Lesson 52

### Выполнили служебные миграции
- Выполнили миграции командой `python manage.py migrate`
Это создало служебные таблицы в базе данных, которые используются для работы с пользователями, сессиями, административной панелью и т.д.

- Создали суперпользователя командой `python manage.py createsuperuser`

### Сделали первую модель `Card` и миграции к ней

**commit: `lesson_52: первая модель cards`**

### Знакомство с `Shell Plus` и работа с моделью `Card` в интерактивной оболочке Django
- Установка `Shell Plus` командой `pip install django-extensions`
- Добавление `django_extensions` в `INSTALLED_APPS` в файле `settings.py`
- Запуск `Shell Plus` командой `python manage.py shell_plus` (для отображения SQL запросов в консоли - `python manage.py shell_plus --print-sql`
- Для того, чтобы начать работать с моделью `Card` в интерактивной оболочке Django, нужно выполнить команду `python manage.py shell_plus`


**commit: `lesson_52: установка Shell Plus и подготовка ORM`**

### CRUD Операции с этой моделью
1. Создание записи
card = Card(question='Пайтон или Питон?!', answer='Пайтон')
card.save()

2. Чтение записи
card = Card.objects.get(pk=1)
Мы можем добыть любые данные из записи, просто обратившись к атрибутам модели:
card.question
card.answer
card.upload_date

3. Обновление записи
card = Card.objects.get(pk=1)
card.question = 'Питон или Пайтон?!!'

4. Удаление записи
card = Card.objects.get(pk=1)
card.delete()

5. Как можно откатить миграции?
- Целиком для приложения `cards` командой `python manage.py migrate cards zero`
- Вернуться к конкретной миграции `python manage.py migrate cards 0001_initial`

**commit: `lesson_52: базовые CRUD Операции с моделью Card`**

### Подключение модели `Card` в административной панели
- Создали файл `admin.py` в приложении `cards` (если его нет)
- Зарегистрировали модель `Card` в административной панели
- `settings.py` `LANGUAGE_CODE = 'ru-ru'` - для русского языка в админке

```python
from django.contrib import admin
from .models import Card

# admin.site.register(Card)

@admin.register(Card)
class CardAdmin(admin.ModelAdmin):
    pass
```

- создаем суперпользователя `python manage.py createsuperuser`

**commit: `lesson_52: подключил модель Card в административной панели`**

### Методы объектного менеджера `objects`
- `all()` - возвращает все объекты модели
- `filter()` - возвращает объекты, которые соответствуют условиям фильтрации
- `get()` - возвращает объект, который соответствует условиям фильтрации
- `exclude()` - возвращает объекты, которые НЕ соответствуют условиям фильтрации
- `order_by()` - возвращает объекты, отсортированные по указанному полю
- `first()` - возвращает первый объект из выборки
- `last()` - возвращает последний объект из выборки
- `count()` - возвращает количество объектов в выборке
- `exists()` - возвращает True, если хотя бы один объект соответствует условиям фильтрации
- `delete()` - удаляет объекты, которые соответствуют условиям фильтрации
- `update()` - обновляет объекты, которые соответствуют условиям фильтрации

1. Получили все карточки `Card.objects.all()` - получаем ленивый запрос `LIMIT 21`
НО!
```python
for card in Card.objects.all():
    print(card.question)
```
Этот код не вызовет дополнительных запросов к базе данных, так как `all()` 
возвращает QuerySet, который хранит в себе все объекты модели, которые соответствуют условиям фильтрации.

2. Получили карточку по ID `Card.objects.get(pk=1)`
3. Получили все карточки с вопросом "Пайтон или Питон?!" `Card.objects.filter(question='Пайтон или Питон?')`
4. Получили первую карточку с вопросом "Пайтон или Питон?!" `Card.objects.filter(question='Пайтон или Питон?').first()`
5. Получаем с помощью лукапа `contains` все карточки с вопросом, содержащим слово "или" `Card.objects.filter(question__contains='или')`
6. Считаем карточки с вопросом "Пайтон или Питон?!" `Card.objects.filter(question='Пайтон или Питон?').count()`
7. Считаем все карточки `Card.objects.all().count()`
8. Получаем карточки добавленные во вторник `Card.objects.filter(upload_date__week_day=3)`


**commit: `lesson_52: методы объектного менеджера objects`**

**commit: `hw_30: done`** 
Загрузил решение ДЗ №30

## Lesson 53
https://icons.getbootstrap.com/ - иконки для BS5
Их надо подключить по ссылке в шаблоне `base.html`

### Сделаем чтение из БД в каталоге карточек
- В файле `views.py` в функции `catalog` изменили возврат словаря на возврат списка карточек из БД
- В файле-вставке `include/card_preview.html` изменили вставку данных id карточки на `card.id` (что соответствует полю id в БД)

**commit: `lesson_53: сделал чтение из БД в каталоге карточек`**

### Сделаем детальное отображение карточки из БД по ID
- В файле `views.py` в функции `get_detail_card_by_id` изменили возврат словаря на возврат карточки из БД
- В файлах `card_detail.html`, `card_preview.html` изменили вставку данных просмотров и добавления в избранное на `card.views` и `card.adds` (что соответствует полям views и adds в БД)

**commit: `lesson_53: сделал детальное отображение карточки из БД по ID`**

### Добавили теги в модель `Card`
- Добавили поле `tags` в модель `Card`
- Создали миграцию командой `python manage.py makemigrations`
- Применили миграцию командой `python manage.py migrate`
- Подключили модель `Card` в административной панели через декоратор `@admin.register(Card)`

**commit: `lesson_53: добавил теги в модель Card`**

### Lookups
- Еще раз пробежались по лукапам 

### `get_object_or_404` для детального отображения карточки по ID

**commit: `lesson_53: get_object_or_404 для детального отображения карточки по ID`**

### В общих чертах разобрали `Q` объекты и `F` объекты
- Для `get_detail_card_by_id` сделали увеличение просмотров на + 1 через `F` объект

**commit: `lesson_53: F объект для увеличения просмотров карточки`**

### hw_31:

### Сортировка для каталога 

- **`sort`** - ключ для указания типа сортировки с возможными значениями: `date`, `views`, `adds`.
- **`order`** - опциональный ключ для указания направления сортировки с возможными значениями: `asc`, `desc`. По умолчанию `desc`.
#### Примеры URL-запросов

1. Сортировка по дате добавления в убывающем порядке (по умолчанию): `/cards/catalog/`
2. Сортировка по количеству просмотров в убывающем порядке: `/cards/catalog/?sort=views`
3. Сортировка по количеству добавлений в возрастающем порядке: `/cards/catalog/?sort=adds&order=asc`
4. Сортировка по дате добавления в возрастающем порядке: `/cards/catalog/?sort=date&order=asc`

**commit: `hw_31: сделал сортировку для каталога`**


## Lesson 54
- Разборабли hw_31
- Разборабли hw_32
- Описали модели, чтобы они соответствовали базе данных
- Подключили боевую базу данных SQLite
- Создали служебные таблицы (просто сделали `migrate`)
- Создали файлы миграций
- Применили миграции в фейковом режиме `--fake`
- Проверили что все работает
- Сделали кликабельными теги в каталоге карточек
- Установили `django-debug-toolbar` и настроили его
- Оптимизировали запросы в каталоге
- Подключили кеширование в настройках и кешировали каталог


## Lesson 55
- Типы отношений в базах данных и их реализация в Django
- Создали модель `Tag` и связали ее с моделью `Card` через отношение `ManyToManyField`
- Многие ко многим (ManyToManyField)

### CRUD операции с моделями `Card` и `Tag`
0. Запустим shell plus с print sql командой `python manage.py shell_plus --print-sql`
1. Создадим объекты модели `Tag`:
- `tag1 = Tag.objects.create(name='Python')`
2. Добавим теги к существующим записям. Просто по ID
- `card = Card.objects.get(pk=1)`
- `tag = Tag.objects.get(pk=3)`
- `card.tags.add(tag)`
- `card.tags.all()`
3. Добавим тег по имени "java_script", найдем ID и через ADD добавим к карточке
- `tag = Tag.objects.get(name="java_script")`
4. В один запрос получим карточки по тегу "java_script"
- `Card.objects.filter(tags__name="java_script")`
- cards_by_tag = tag.cards.all()
- Напишем новый запрос, который создаст карточку и добавит к ней теги 

Получаем или создаем теги

Метод `get_or_create` в Django ORM — это удобный способ получить объект из базы данных, 
если он существует, или создать новый, если он не найден. Он возвращает кортеж, содержащий 
объект и булево значение: первый элемент кортежа — это сам объект, второй — флаг, указывающий,
был ли объект создан в результате текущего вызова (True, если объект был создан, и False, 
 
Если объект был получен из базы данных).

```python
tag_names = ["python", "recursion"]
tags = [Tag.objects.get_or_create(name=name)[0] for name in tag_names]  
# Используем индекс [0] чтобы получить объект Tag
```
5. Создаем карточку
new_card = Card(question="Как работает рекурсия в Python?", answer="Рекурсия - это...")
new_card.save()  # Сохраняем карточку в базу данных

6. Добавляем все теги к карточке
for tag in tags:
    new_card.tags.add(tag)
    
7. Получим все карточки, у которых в теге есть "on"
cards = Card.objects.filter(tags__name__icontains="on")

**commit: `lesson_55: многие ко многим (ManyToManyField)`**


### Один ко многим (ForeignKey)

- Создали модель категорий и добавили данные.

### Один ко многим (ForeignKey)

- Создали модель категорий и добавили данные.

1. Получить объект категории ID 1
cat1 = Category.objects.get(pk=1)
2. Получаем все карточки по категории cat1
cat1.cards.all()

3. Нам приходит на вход карточка и категория, которую мы хотим присвоить карточке.
Мы не знаем есть такая категория или нет. Попробуем сделать это через get_or_create

new_card = Card.objects.create(question="Какой-то вопрос", answer="Какой-то ответ")
some_cat = Category.objects.get_or_create(name="Новая категория")[0]

new_card.category = some_cat
new_card.save()

**commit: `lesson_55: один ко многим (ForeignKey)`**

### Агрегирующие функции и аннотации

`Count`, `Sum`, `Avg`, `Max`, `Min`. Метод `values()` 

`count` - количество записей
`sum` - сумма значений
`avg` - среднее значение
`max` - максимальное значение
`min` - минимальное значение

`values()` - возвращает QuerySet, содержащий словари, представляющие объекты модели.

1. Получим категорию pk=1
cat1 = Category.objects.get(pk=1)
2. Посчитаем количество карточек в категории
cat1.cards.count()
3. Получим карточку pk=1
card1 = Card.objects.get(pk=1)
4. Посчитаем количество карточек для каждой категории. Annotate
categories_with_counts = Category.objects.annotate(cards_count=Count('cards')).all()
5. Посчитать сколько тегов у каждой карточки и отсортировать по убыванию
cards_with_tag_counts = Card.objects.annotate(tags_count=Count('tags')).order_by('-tags_count').all()
6. Получим карточку с максимальным количеством тегов aggreate
max_views = Card.objects.aggregate(max_views=Max('views'))
max_tags_card = Card.objects.aggregate(max_tags=Max('tags'))


**commit: `lesson_55: кастомизация админки`**
Двигались по конспекту (до создания собственного фильтра в админке)


## Lesson 56
- Делаем собственный фильтр в админки (Наследование от `SimpleListFilter`)
- Сделали собственный фильтр, который позволяет фильтровать карточки по наличию кода в них `class CardCodeFilter(SimpleListFilter)`

**commit: `lesson_56: Создание своего фильтра SimpleListFilter`**

- Поправили таблицы - к таблице многие-ко-многим добавили поле id - первичный ключ
- Сделали миграции

**commit: `lesson_56: добавил первичный ключ к таблице многие-ко-многим`**

- Установил `django-djazzmin` и настроил его
- `pip install django-djazzmin`
- Добавил `djazzmin` в `INSTALLED_APPS` в файле `settings.py`

**commit: `lesson_56: установил и настроил django-djazzmin`**

- Сделал копию служебного шаблона `change_form.html` и вклинились в `{% block after_field_sets %}`
- Добавил в админке карточек кнопку "Создать карточку с тегами" `{% block object-tools-items %}`

**commit: `lesson_56: кастомизация шаблона change_form.html`**


## Lesson 58

- Разобрали возможность делать dump и load данных в Django
- Команды `dumpdata` и `loaddata`, а так же дополнительные настройки
- Как сделать дамп приложения, как указать отсутпы и кодировку
- Сделали дамп и загрузку данных

**commit: `lesson_58: dump.json`**

### Формы в Django
- Создали форму не связанную с моделью. Форма для добавления карточек
- Создали представление, обрабатывающее метод POST и возвращающее форму
- Создали шаблон для формы
- Протестировали работу формы
- Проверили валидацию формы

**commit: `lesson_58: базовая форма для добавления карточек`**
- Дополнили шаблон с построчным рендером полей ввода
- Добавили категорию как выпадающий список `form.ChoiceField`

**commit: `lesson_58: дополнил шаблон с построчным рендером полей ввода`**
- Передали классы и атрибуты в форму через класс формы
- Поправили шаблон и перешли на BS-5 с адаптивной версткой
- Добавили обработку формы и сохранение данных в представлении

**commit: `lesson_58: BS5 и сохранение данных из формы`**

- Описали собственный класс валидатор `CodeBlockValidator`
- Подключили его в форме
- Протестировали работу валидатора (пока слишком жесткий) - будем выключать и дописывать

**commit: `lesson_58: собственный валидатор CodeBlockValidator`**

## Lesson 59
- Написали форму связанную с моделью
- Обновили представление, чтобы оно работало с формой связанной с моделью
- Код получился вдвое короче
- Добавили валидатор для поля `tags` в форме (отсутствие пробелов)
- Добавили метод очистки тегов в форме
- Проверили работу формы

**commit: `lesson_59: форма добавления карточек связанная с моделью`**

- Базовая форма добавления файла
- Минимальный комплект: класс формы, представление, шаблон
- Получения файла через `chunks()` и сохранение его в файловую систему
- Проблема: перезапись файла при одинаковых именах

**commit: `lesson_59: базовая форма добавления файла`**

## Lesson 60 - Классовые представления

### Разбор ДЗ с поиском в каталоге карточек
- Модифицировали функцию-представление `catalog` в файле `views.py` так, чтобы она принимала GET-параметр `search_query`
- Добавили в шаблон `catalog.html` форму для поиска карточек с GET-параметром `search_query` и радио-кнопками для выбора поля поиска
- Протестировали работу поиска
- Добавили отключение кеширования браузера для страницы каталога, чтобы видеть увеличение просмотров в катаолге

**commit: `lesson_60: разбор ДЗ с поиском в каталоге карточек`**

- Добавили экземпляр пагинатора в представление `catalog` в файле `views.py`
- Добавили работу с пагинатором в шаблоне `catalog.html`

**commit: `lesson_60: добавил пагинацию в каталог карточек`**

### Классовые представления

- Переписали функцию представления add_card на классовое представление с наследованием от `View`

**commit: `lesson_60: переписал функцию представления add_card на классовое представление`**

- Переписали about и главную страницу на классовые представления (наследование от `TemplateView`)
- Создали миксин, который добавляет к контексту меню, подмешали его в один класс


**commit: `lesson_60: переписал about и главную страницу на TemplateView`**

- Добавили в AboutView и IndexView атрибут `extra_context` и добавили в него подсчет
реального количества карточек и пользователей

**commit: `lesson_60: добавил в AboutView и IndexView подсчет реального количества карточек и пользователей`**

## Lesson 61

### ListView
- Переписали представление `catalog` на классовое представление `ListView`
- Добавили жадную загрузку связанных объектов
- Использовали `__iregex` для РАБОЧЕГО регистронезависимого поиска вместо `__icontains` (актуально для SQLite)
- Кешировали каталог силами шаблонизатора
- Использовали `page_obj.paginator.count` для подсчета количества карточек (не иницирует новых запросов к БД)
- Использовали переменные для кеша, которые позволяют кешировать разные варианты страницы (по запросам и сортировкам)`{% cache 90 catalog_content page_obj.number sort order search_query %}`

**commit: `lesson_61: catalog на классовое представление ListView и кеширование`**


### DetailView
- Переписали представление `get_detail_card_by_id` на классовое представление `DetailView`
- Обновили шаблон `card_detail.html` для работы с классовым представлением


**commit: `lesson_61: get_detail_card_by_id на классовое представление DetailView`**


### Кеширование MenuMixin
- Использовали `from django.core.cache import cache` для кеширования меню, так как оно делало с каждой страницы по 2 запроса в БД

**commit: `lesson_61: кеширование меню с помощью cache`**


### CreateView
- Переписали представление добавления карточки на классовое представление `CreateView` - `AddCardCreateView(MenuMixin, CreateView)`

**commit: `lesson_61: добавление карточки на классовое представление CreateView`**

## Lesson 62

### UpdateView и DeleteView
- Добавили представления `UpdateView` и `DeleteView` для редактирования и удаления карточек
- Внесли в форму `CardForm` неудачную правку в инициализатор, попытка изменить теги на строку при открытии формы редактирования
- А так же удачную правку для тегов, чтобы они на самом деле обновлялись (а не только добавлялись)
- Шаблон для 404 ошибки (работает пока только в боевом режиме `DEBUG=False`)

**commit: `lesson_62: UpdateView и DeleteView и 404`**


### Users app
- Создали приложение `users` и подключили его в `INSTALLED_APPS`
- Подготовили маршруты и namespace для приложения `users`

**commit: `lesson_62: users app и подготовка маршрутов`**

- прописали функции-представления для авторизации и выхода из системы
- создали шаблон для входа в систему
- `LoginUserForm` - форма для входа в систему
- Протестировали вход и выход из системы
- Нашли в браузере куки и сессии

**commit: `lesson_62: функции-представления для авторизации и выхода из системы`**

- `redirect_field_name` = 'next' во вьюшке добавления карточек
- Так же, добавили миксин `LoginRequiredMixin` для защиты представлений от неавторизованных пользователей
- В шаблон `login.html` добавили `next` для перехода на страницу, с которой пришел пользователь
`<input type="hidden" name="next" value="{{ request.GET.next }}">`
- Пофиксили редирект при успешной авторизации `return redirect(request.POST.get('next', 'catalog'))`
Это позволяет переходить на страницу, с которой пришел пользователь после авторизации
- Поработали с меню, теперь там отображается имя пользователя и ссылка на выход из системы
- 
**commit: `lesson_62: защита представлений от неавторизованных пользователей и перенаправление`**

## Lesson 63

#BUG: Нашли косяк с кешированием представления по тегам (отображается только кеш первого тега)
#TODO: Добавить оптимизация шаблонов каталога
- base_catalog.html
- include/card_preview.html
- card_detail.html
- catalog.html
- profile_cards.html ?
- cards_by_tag.html (наследуется от base_catalog.html)
- cards_by_category.html (наследуется от base_catalog.html)

### Переписали функцию логина на LoginUser(LoginView)
- Использовали `LoginView` вместо функции `login_user` - это классовое представление для входа в систему
- В нем использовали служебную форму `AuthenticationForm` для входа в систему
- А так же прописали `success_url` для перехода после успешного входа с проверкой на `next`

**commit: `lesson_63: переписал функцию логина на LoginUser(LoginView)`**


- Написали свою форму с наследованием от `AuthenticationForm` и добавили в нее BS5 стили
- Переписали представление выхода из системы на `LogoutUser(LogoutView)`
- Добавили оформления в шаблон `login.html`

**commit: `lesson_63: своя форма входа и выхода из системы`**

- Поэкспериментировали с `LoginRequiredMixin` и порядком его указания в классе представления
- `MenuMixin` никак не влияет на работу `LoginRequiredMixin`
- Прописал в настройках `LOGIN_URL` для того, чтбы не делать это в каждом защищенном представлении
- Убрал `login_url` из 2 защищенных представлений и проверил работу

**commit: `lesson_63: LoginRequiredMixin и LOGIN_URL`**

### Добавление пользователя в описание карточки
- `author = models.ForeignKey(get_user_model(), on_delete=models.SET_NULL, related_name='cards', null=True, default=None, verbose_name=_('Автор'))`
- Добавили пользователя в шаблоны отображения карточек
- Модифицировали view для добавления карточки, чтобы автором был текущий пользователь

**commit: `lesson_63: добавил пользователя в описание карточки`**

- `class LogoutUser(LogoutView): next_page = reverse_lazy('users:login')`
- Поправили `urls.py` для приложения `users` c использованием класса `LogoutUser`

**commit: `lesson_63: LogoutUser(LogoutView)`**

- Регистрация пользователя через простую форму связанную с моделью `RegisterUserForm(forms.ModelForm):`
- Функция представления `register_user` для регистрации пользователя
- Шаблон `register.html` для регистрации пользователя
- Сообщение спасибо за регистрацию `register_done.html`


**commit: `lesson_63: регистрация пользователя`**

## Lesson 64

### Класс регистрации пользователя RegisterUser
- Переписали функцию регистрации на класс `RegisterUser(CreateView)` - специализированного родителя нет, поэтому используем `CreateView`
- Поправили `urls.py` для приложения `users` c использованием класса `RegisterUser`
- Проверили, что старая форма не хеширует пароли (раньше это было в функции вьюшки)
- Переписали старую форму на класс `RegisterUserForm(UserCreationForm)` - специлизированный родитель для регистрации пользователя
- Протестировали хеширование пароля (Есть!)


**commit: `lesson_64: класс регистрации пользователя RegisterUser`**

### Авторизация опционально через email или username

- Создаем файл бэкенда аутентификации `users/authentication.py`
- Определяем в нем собственный бэкенд
- Подключаем его в настройках `AUTHENTICATION_BACKENDS`
- Указываем там стандартный бэкенд `django.contrib.auth.backends.ModelBackend` и наш собственный `users.authentication.EmailAuthBackend`
- Поправили форму входа `LoginUserForm` (подпись что вы можете войти по email или username)


**commit: `lesson_64: авторизация опционально через email или username`**

### Начали работу над личным кабинетом

#### Шаблоны
- Создали шаблон `base_profile.html` который расширяет `base.html` и служит основой для личного кабинета
- Создали шаблон `profile.html` который расширяет `base_profile.html` и содержит информацию о пользователе а так же возможность внести изменения в профиль
- Создали include `profile_nav.html` для навигации по личному кабинету
- Создали шаблон `password_change_form.html` для изменения пароля
- Создали шаблон `password_change_done.html` для успешного изменения пароля
- Создали шаблон `profile_cards.html` для отображения карточек пользователя

#### Маршруты
- `users/profile/` - `ProfileUser` - личный кабинет пользователя
- `users/password_change/` - `UserPasswordChange` - изменение пароля пользователя
- `users/profile_cards/` - `UserCardsView` - карточки пользователя

#### Представления
- `UserPasswordChange` - изменение пароля пользователя. Наследуется от `PasswordChangeView` - стандартного класса для изменения пароля. Использует пользовательскую форму `UserPasswordChangeForm`, которая наследуется от `PasswordChangeForm`
- `UserPasswordChangeDone` - успешное изменение пароля пользователя. Наследуется от `TemplateView`
- `UserCardsView` - карточки пользователя. Наследуется от `ListView`. Переопределяет метод `get_queryset` для получения карточек пользователя

**commit: `lesson_64: начал работу над личным кабинетом`**


## Lesson 65

### Обзор того, что сделали на прошлом уроке
- Пробежались по шаблонам, маршрутам и представлениям личного кабинета
- Почему у нас некоторые поля формы не редактируемые в профиле?
- Почему на текущий момент не сохраняются изменения в профиле?

- На данном пути 2 варианта развития: - работа с аватарами, восстановление пароля через email
- Закончим работу с ЛК пользователя


### Расширили модель пользователя

```python
from django.contrib.auth.models import AbstractUser
from django.db import models

class User(AbstractUser):
    photo = models.ImageField(upload_to='users/images/%Y/%m/%d/', blank=True, null=True, verbose_name='Фотография')
    date_birth = models.DateTimeField(blank=True, null=True, verbose_name='Дата рождения')

    def __str__(self):
        return self.username
```

В Django, `AbstractUser` - это базовый класс для модели пользователя, который включает в себя большинство полей и методов, необходимых для аутентификации и авторизации пользователей. Он включает такие поля, как `username`, `password`, `email`, `first_name`, `last_name`, `is_staff`, `is_active`, `date_joined` и другие.

Когда вы создаете свой собственный класс `User`, наследуясь от `AbstractUser`, вы переопределяете стандартную модель пользователя Django. Это позволяет вам добавить дополнительные поля, такие как `photo` и `date_birth`, которые не включены в стандартную модель пользователя.

Ваш класс `User` включает следующие поля:

- `photo`: Это поле `ImageField`, которое позволяет пользователям загружать фотографии. Параметр `upload_to` указывает, где эти фотографии должны быть сохранены. В данном случае, они сохраняются в подкаталоге `users/images/%Y/%m/%d/` каталога `MEDIA_ROOT`. Параметры `blank=True, null=True` указывают, что это поле не является обязательным.
- `date_birth`: Это поле `DateTimeField`, которое позволяет пользователям указывать свою дату рождения. Оно также не является обязательным.

Причина, по которой вы используете наследование от `AbstractUser`, а не связь "один к одному" с другой моделью для хранения дополнительной информации о пользователе, заключается в том, что это делает вашу модель пользователя более гибкой и удобной в использовании. Вместо того чтобы каждый раз, когда вам нужна дополнительная информация о пользователе, получать ее из связанной модели, вы можете просто обратиться к полям `photo` и `date_birth` напрямую, как если бы они были частью стандартной модели пользователя.

---

В Django, параметр `upload_to` в поле `ImageField` или `FileField` используется для указания подкаталога внутри `MEDIA_ROOT`, где будут сохраняться загруженные файлы.

Строка `'users/images/%Y/%m/%d/'` в `upload_to` определяет путь к подкаталогу, где будут сохраняться файлы. В этом пути используются специальные символы `%Y`, `%m` и `%d`, которые заменяются на текущий год, месяц и день соответственно. Это позволяет автоматически организовать загруженные файлы по датам, что может быть полезно, если вы ожидаете большое количество загружаемых файлов.

Таким образом, если пользователь загрузит файл 5 июля 2022 года, файл будет сохранен в подкаталоге `users/images/2022/07/05/` каталога `MEDIA_ROOT`.

Пожалуйста, учтите, что `MEDIA_ROOT` должен быть предварительно определен в настройках вашего Django проекта. Это корневой каталог, где Django будет сохранять все загруженные файлы.

---

- Установим pillow для работы с изображениями `pip install pillow`
- Обновим requirements.txt `pip freeze > requirements.txt`
- Подключим новую модель пользователя в настройках `AUTH_USER_MODEL = 'users.User'`

---
- Так как пользователь, достаточно важная часть приложения, пришлось пересоздать миграции.
- Удалил все миграции всех приложений.
- Удалил базу данных.
- Создал новые миграции.
- Применил миграции.
- Восстановил контент из дампа командой `python manage.py loaddata dump.json`


**commit: `lesson_65: расширил модель пользователя`**

### Починим фотографии в профиле

- Для этого нужно определить две вещи в настройках:
- MEDIA_ROOT - корневой каталог для загружаемых файлов
- MEDIA_URL - URL, по которому можно получить доступ к загружаемым файлам

```python
MEDIA_URL = '/media/'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')
```

- Правки в главный `urls.py` для отображения медиафайлов в режиме отладки

```python
from django.conf.urls.static import static
from django.conf import settings
if settings.DEBUG:
    import debug_toolbar

    urlpatterns = [
                      path('__debug__/', include(debug_toolbar.urls)),
                      # другие URL-паттерны
                  ] + urlpatterns
    
    # Добавляем обработку медиафайлов
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
```

- Правки в `nav_menu.html` для кликабельности username

```html
 <a class="nav-link" href="{% url 'users:profile' %}">{{ user.username }}</a>
```

А так же мелкие правки в стили для отображения фотографии пользователя


**commit: `lesson_65: починил фотографии в профиле`**


### Доделываем смену пароля в ЛК

Отсутствовал маршрут в `urls.py` для `UserPasswordChangeDone`
Добавили его и протестировали работу смены пароля

**commit: `lesson_65: доделал смену пароля в ЛК`**

### Восстановление пароля через email
Для этого нам необходимо подготовить целый ряд представлений,  шаблонов и форм:

Итого для работы с паролями:

### Классы и их функциональность

1. **PasswordChange**
   - Родитель: `PasswordChangeView`
   - Атрибуты:
     - `template_name`: Указать путь к шаблону формы смены пароля.
     - `form_class`: Указать класс формы для смены пароля.
     - `success_url`: Использовать `reverse_lazy` для указания URL-адреса перенаправления после успешной смены пароля.
     - `extra_context`: Словарь с дополнительным контекстом, например `{'title': 'Смена пароля'}`.
   - Методы:
     - `form_valid`: Метод, вызываемый при успешной валидации формы. Может быть переопределен для добавления дополнительной логики.

2. **PasswordChangeDone**
   - Родитель: `TemplateView`
   - Атрибуты:
     - `template_name`: Указать путь к шаблону страницы, подтверждающей успешное изменение пароля.
     - `extra_context`: Словарь с дополнительным контекстом, например `{'title': 'Пароль успешно изменен'}`.

3. **PasswordReset**
   - Родитель: `PasswordResetView`
   - Атрибуты:
     - `template_name`: Указать путь к шаблону формы запроса на сброс пароля.
     - `form_class`: Указать класс формы для запроса сброса пароля.
     - `email_template_name`: Путь к шаблону email, который будет отправлен для сброса пароля.
     - `success_url`: Использовать `reverse_lazy` для указания URL-адреса перенаправления после запроса на сброс.
     - `subject_template_name`: Путь к шаблону темы email.
   - Методы:
     - `form_valid`: Метод для дополнительной обработки после отправки формы.

4. **PasswordResetDone**
   - Родитель: `TemplateView`
   - Атрибуты:
     - `template_name`: Указать путь к шаблону страницы, подтверждающей отправку инструкций по сбросу пароля.
     - `extra_context`: Словарь с дополнительным контекстом, например `{'title': 'Инструкции отправлены'}`.

5. **PasswordResetConfirm**
   - Родитель: `PasswordResetConfirmView`
   - Атрибуты:
     - `template_name`: Указать путь к шаблону формы для ввода нового пароля.
     - `form_class`: Указать класс формы для ввода нового пароля.
     - `success_url`: Использовать `reverse_lazy` для указания URL-адреса перенаправления после успешного сброса пароля.
   - Методы:
     - `form_valid`: Метод для дополнительной обработки после успешной смены пароля.

6. **PasswordResetComplete**
   - Родитель: `TemplateView`
   - Атрибуты:
     - `template_name`: Указать путь к шаблону страницы, подтверждающей успешное обновление пароля.
     - `extra_context`: Словарь с дополнительным контекстом, например `{'title': 'Пароль успешно обновлен'}`.

#### Служебный синтаксис в методах
- `reverse_lazy('name_of_route')`: Используется для отложенного получения URL по имени маршрута.
- `form_valid(form)`: Вызывается, когда форма проходит валидацию. Обычно используется для переопределения стандартной логики, например, для выполнения дополнительных действий с объектом перед его сохранением.

Эти элементы должны быть включены в классы и методы для обеспечения функциональности смены и восстановления пароля, а также управления потоком пользователя в приложении Django.

#### Таблица классов и представлений:

| Класс                     | Файл                | Родитель                       | Описание                                                    | Использование                  |
| ------------------------- | ------------------- | ------------------------------ | ----------------------------------------------------------- | ------------------------------ |
| `PasswordChange`          | `views.py`          | `PasswordChangeView`           | Класс для смены пароля аутентифицированного пользователя.    | Смена пароля                   |
| `PasswordChangeDone`      | `views.py`          | `TemplateView`                 | Отображает страницу об успешном изменении пароля.            | Подтверждение смены пароля     |
| `PasswordReset`           | `views.py`          | `PasswordResetView`            | Обработчик для инициирования процесса сброса пароля.         | Восстановление пароля          |
| `PasswordResetDone`       | `views.py`          | `TemplateView`                 | Отображает страницу, подтверждающую отправку инструкций.     | Подтверждение отправки письма  |
| `PasswordResetConfirm`    | `views.py`          | `PasswordResetConfirmView`     | Позволяет пользователю ввести новый пароль после сброса.     | Ввод нового пароля             |
| `PasswordResetComplete`   | `views.py`          | `TemplateView`                 | Отображает страницу об успешном обновлении пароля.           | Успешное обновление пароля     |


#### Шаблоны

**Шаблоны сброса пароля Django:**

* `password_reset_email.html`: используется для отправки электронного письма с ссылкой для сброса пароля.
* `password_reset_form.html`: используется для отображения формы сброса пароля.
* `password_reset_confirm.html`: используется для отображения страницы подтверждения сброса пароля.
* `password_reset_done.html`: используется для отображения страницы с сообщением о том, что пароль был успешно сброшен.
* `password_change_email.html`: используется для отправки электронного письма с уведомлением о смене пароля.
* `password_change_form.html`: используется для отображения формы изменения пароля.
* `password_change_done.html`: используется для отображения страницы с сообщением о том, что пароль был успешно изменен.

**Описание каждого шаблона:**

* **password_reset_email.html:** 
   * Этот шаблон используется для отправки электронного письма с ссылкой для сброса пароля. 
   * Шаблон должен содержать ссылку, которая направляет пользователя на страницу сброса пароля. 
   * Ссылка должна содержать уникальный идентификатор пользователя и токен сброса пароля.
   * Шаблон также может содержать сообщение с инструкциями о том, как сбросить пароль.

* **password_reset_form.html:**
   * Этот шаблон используется для отображения формы сброса пароля. 
   * Форма должна содержать поля для ввода нового пароля и подтверждения нового пароля.
   * Форма должна также содержать скрытое поле с токеном сброса пароля.
   * Когда пользователь отправляет форму, Django проверит токен сброса пароля и, если он действителен, сбросит пароль пользователя.

* **password_reset_confirm.html:**
   * Этот шаблон используется для отображения страницы подтверждения сброса пароля. 
   * Страница должна содержать сообщение с информацией о том, что пароль пользователя был успешно сброшен.
   * Страница также может содержать ссылку, которая направляет пользователя на страницу входа в систему.

* **password_reset_done.html:**
   * Этот шаблон используется для отображения страницы с сообщением о том, что пароль был успешно сброшен. 
   * Страница должна содержать сообщение с информацией о том, что пароль пользователя был успешно сброшен.
   * Страница также может содержать ссылку, которая направляет пользователя на страницу входа в систему.

* **password_change_email.html:**
   * Этот шаблон используется для отправки электронного письма с уведомлением о смене пароля. 
   * Шаблон должен содержать сообщение с информацией о том, что пароль пользователя был изменен.
   * Шаблон также может содержать ссылку, которая направляет пользователя на страницу изменения пароля.

* **password_change_form.html:**
   * Этот шаблон используется для отображения формы изменения пароля. 
   * Форма должна содержать поля для ввода текущего пароля, нового пароля и подтверждения нового пароля.
   * Когда пользователь отправляет форму, Django проверит текущий пароль пользователя и, если он верен, изменит пароль пользователя.

* **password_change_done.html:**
   * Этот шаблон используется для отображения страницы с сообщением о том, что пароль был успешно изменен. 
   * Страница должна содержать сообщение с информацией о том, что пароль пользователя был успешно изменен.
   * Страница также может содержать ссылку, которая направляет пользователя на страницу входа в систему.

Промежуточный коммит
**commit: `lesson_65: промежуточный коммит восстановление пароля через email`**

#### Маршруты

- Маршрут для сброса пароля
- Маршрут для подтверждения сброса пароля
- Маршрут для ввода нового пароля
- Маршрут для завершения сброса пароля

#### Settings 

Настраиваем `EMAIL_BACKEND` для вывода в консоль

```python
EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'
```

Тестирование прошло успешно.
Мы увидели емейл в консоли, который отправился при запросе сброса пароля
После этого мы успешно сменили пароль пользователю

**commit: `lesson_65: восстановление пароля через email - тест в терминале`**

Сделали восстановление пароля через email

**commit: `lesson_65: восстановление пароля через email`**

# Идеальный план на последующие уроки (будет сокращен)

## Lesson 66 - Деплой на TimeWeb с автоматическим CI/CD

### Подготовка к деплою
1. Регистрация на TimeWeb. https://timeweb.cloud/r/pj17346
2. Выбор тарифа и создание виртуального сервера.
3. Покупка домена и настройка его на TimeWeb. 
4. Подгтовка проекта к деплою
   1. Убедитесь что в проекте нет лишних файлов и папок.
   2. Создайте файл `requirements.txt` с зависимостями проекта.
   3. Если вы создавали `.env` файл, добавьте его в `.gitignore`.
   4. Убедитесь что `.env.example` содержит все необходимые переменные.
   5. Если в вашей БД есть контент, создайте дамп БД
   6. Можете прогнать тест. Просто склонируйте проект в соседнюю папку и попробуйте запустить.
   7. Разместите проект на Гитхабе. Приложите ссылку на репозиторий в комментарии к ДЗ.
   8. Приложите архив с кодом в само ДЗ.
5. Команды для подготовки приложения к запуску на сервере
6. Деплой

**commit: `lesson_66: подготовка к деплою`**

### Настройка дополнительных возможностей
1. Настройка SSL-сертификатов через Let's Encrypt для безопасного соединения.
2. Настройка автоматического обновления SSL-сертификатов.
3. Настройка автоматического деплоя через CI/CD.
4. Концепция DNS имен для домена.
5. Прописывание DNS имен для домена вашего домена


**commit: `lesson_66: развернули приложение и прописали DNS имена для домена pydeck.ru`**

### Дополнительная настройка для работы проекта


1. Настройка `DEBUG` в `settings.py` для отладочного режима. Чтобы на сервере не отображались отладочные сообщения, установите `DEBUG = False` и добавьте домен сервера в список `ALLOWED_HOSTS`.
DEBUG = os.getenv('DEBUG')

2. Настройка `ALLOWED_HOSTS` в `settings.py` для домена pydeck.ru.
ALLOWED_HOSTS - это список хостов, которые могут обращаться к нашему сайту
ALLOWED_HOSTS = ['pydeck.ru', 'www.pydeck.ru', 'localhost', '127.0.0.1']

3. Настройка CSRF_TRUSTED_ORIGINS в `settings.py` для безопасной работы с формами.
CSRF_TRUSTED_ORIGINS - это список доменов, с которых можно отправлять POST-запросы без токена CSRF
CSRF_TRUSTED_ORIGINS = ['https://pydeck.ru', 'https://www.pydeck.ru']

4. Добавление IF DEBUG для отладочной панели Django.
INTERNAL_IPS  - это список IP-адресов, с которых можно получить доступ к отладочной панели Django
if DEBUG:    
    INTERNAL_IPS = [
        '127.0.0.1',
    ]


**commit: `lesson_66: дополнительная настройка для работы проекта`**

## Lesson 67 - Концепция авторизации через соцсети

### Обзор протокола OAuth2.0

1. Введение в OAuth2.0 и его принципы.
2. Различия между OAuth и OpenID Connect.
3. Пример работы OAuth2.0 на практике в Django.

### Подготовка проекта к авторизации через соцсети

1. Устанавливаем библиотеку `social-auth-app-django` и добавляем ее в `requirements.txt`
https://python-social-auth.readthedocs.io/en/latest/index.html


`pip install social-auth-app-django`
`pip freeze > requirements.txt`

2. Добавляем приложение `social_django` в `INSTALLED_APPS` в `settings.py`

```python
INSTALLED_APPS = [
    ...
    'social_django',
]
```

1. Добавляем настройки `settings.py`
AUTHENTICATION_BACKENDS - список бэкендов аутентификации, для работы с соцсетями
MIDDLEWARE - список промежуточных слоев, для обработки исключений
TEMPLATES - список контекстных процессоров, для передачи данных в шаблоны
SOCIAL_AUTH_URL_NAMESPACE - пространство имен для URL-адресов авторизации

```python
AUTHENTICATION_BACKENDS = (
    'social_core.backends.github.GithubOAuth2',
    'social_core.backends.vk.VKOAuth2',
    'django.contrib.auth.backends.ModelBackend',
)
########
MIDDLEWARE = [
    ...
    'social_django.middleware.SocialAuthExceptionMiddleware',
]
########
TEMPLATES = [
    {
        ...
        'OPTIONS': {
            'context_processors': [
                ...
                'social_django.context_processors.backends',
                'social_django.context_processors.login_redirect',
            ],
        },
    },
]

SOCIAL_AUTH_URL_NAMESPACE = 'social'
```

2. Добавляем в `.env` и `env.example` переменные для авторизации через GitHub и VK

GITHUB_KEY=None
GITHUB_SECRET=None
VK_KEY=None
VK_SECRET=None

3. Настройки в `settings.py` для авторизации через GitHub и VK

```python
SOCIAL_AUTH_URL_NAMESPACE = 'social'
SOCIAL_AUTH_GITHUB_KEY = os.getenv('GITHUB_KEY')
SOCIAL_AUTH_GITHUB_SECRET = os.getenv('GITHUB_SECRET')

SOCIAL_AUTH_VK_OAUTH2_KEY = os.getenv('VK_KEY')
SOCIAL_AUTH_VK_OAUTH2_SECRET = os.getenv('VK_SECRET')

LOGIN_REDIRECT_URL = '/users/profile/'
LOGOUT_REDIRECT_URL = '/'
```

4. Добавляем URL-адреса для авторизации через соцсети в `urls.py`

```python
from django.urls import include, path

urlpatterns = [
    ...
    path('social-auth/', include('social_django.urls', namespace='social')),
]
```
5. Добавляем в шаблон `profile.html` кнопки для авторизации через GitHub и VK

```html
<form method="post" action="{% url 'users:link_social_account' %}">
  {% csrf_token %}
  <button type="submit" name="provider" value="github" class="btn btn-dark">Привязать GitHub</button>
  <button type="submit" name="provider" value="vk" class="btn btn-dark">Привязать VK</button>
</form>
```

6. Создаем представление для привязки соцсетей к пользователю в `views.py` приложения `users`

```python
from django.views import View
from django.shortcuts import redirect
from social_django.utils import psa

class SocialAuthView(View):

    @psa('social:complete')
    def save_oauth_data(self, request, backend):
        user = request.user
        if backend.name == 'github':
            user.github_id = backend.get_user_id(request)
        elif backend.name == 'vk':
            user.vk_id = backend.get_user_id(request)
        user.save()
        return redirect('users:profile')

    def post(self, request, *args, **kwargs):
        if 'provider' in request.POST:
            provider = request.POST['provider']
            if provider == 'github':
                return redirect('social:begin', backend='github')
            elif provider == 'vk':
                return redirect('social:begin', backend='vk')
        return redirect('users:profile')

```

**commit: `lesson_67: подготовка проекта к авторизации через соцсети`**


### Обновление моделей и представлений
1. Добавление полей для хранения данных соцсетей в модель пользователя.

```python
class User(AbstractUser):
    ...
    github_id = models.CharField(max_length=255, blank=True, null=True)
    vk_id = models.CharField(max_length=255, blank=True, null=True)
```

2. Создание миграций и применение изменений в базе данных.

`python manage.py makemigrations`
`python manage.py migrate`


**commit: `lesson_67: обновление моделей для авторизации через соцсети`**

### Обновление маршрутов
1. Добавление маршрутов для авторизации через соцсети в `urls.py` приложения `users`.

```python
from django.urls import path
from .views import SocialAuthView

urlpatterns = [
    ...
    path('link-social-account/', SocialAuthView.as_view(), name='link_social_account'),
    path('save-oauth-data/<str:backend>/', SocialAuthView.as_view(), name='save_oauth_data'),
]
```

**commit: `lesson_67: обновление маршрутов для авторизации через соцсети`**

### Обновление шаблона login.html

```html
 <h3>Или зайдите через:</h3>
            <a href="{% url 'social:begin' 'vk' %}" class="btn btn-dark">ВКонтакте</a>
            <a href="{% url 'social:begin' 'github' %}" class="btn btn-dark">GitHub</a>
```

**commit: `lesson_67: обновление шаблона login.html`**

### Альтернативный вариант: регистрация через соцсети
17. Обзор преимуществ и недостатков регистрации через соцсети.
18. Пример реализации регистрации через соцсети с помощью `social-auth-app-django`.
19. Обсуждение вопросов безопасности и конфиденциальности.

### Lesson 69 - Разрешения и группы пользователей в Django

На данном этапе у нас есть кастомный User наследник AbstractUser, который содержит дополнительные поля для хранения данных пользователя. Мы добавили возможность авторизации через соцсети и привязку аккаунтов GitHub и VK к пользователю. 

Но мы не видем пользователей в админке, надо это исправить.

Нам нужно зарегистрировать модель в админке.

#TODO - кастомизация странички 403 - доступ запрещен

Создали пользователя1 и пользователя2.
Пользователь1 получил статус персонала.
После чего он смог попасть в админку, но не увидел ни одной модели.
Выдали ему право на просмотр модели пользователи, а так же карточки.
Теперь он их видет, но не может ничего сделать, в админке, даже изменить себе аватарку.

Пользователь2 получил разерешние редактирования карточек.
Однако карточки редактировать по прежнему могут ВСЕ кто залогинен.
Попробуем это исправить.
Нам нужен новый миксин - `PermissionRequiredMixin`
Который проверяет права пользователя на выполнение действия.

```python
class EditCardUpdateView(MenuMixin, LoginRequiredMixin, PermissionRequiredMixin, UpdateView):
    model = Card  # Указываем модель, с которой работает представление
    form_class = CardForm  # Указываем класс формы для редактирования карточки
    template_name = 'cards/add_card.html'  # Указываем шаблон, который будет использоваться для отображения формы
    context_object_name = 'card'  # Имя переменной контекста для карточки
    success_url = reverse_lazy('catalog')  # URL для перенаправления после успешного редактирования карточки
    permission_required = 'cards.change_card'  # Указываем право, которое должен иметь пользователь для доступа к представлению

    # ТЕСТ - надо проверить))
    def has_permission(self):
        return self.request.user.is_staff or self.request.user == self.get_object().author
```

Теперь происходит проверка на права пользователя на редактирование карточки.

АДМИН ИМЕЕТ ВСЕ ПРАВА!

Добавим в include card_preview.html кнопку редактирования карточки

```html
{% if user.is_authenticated and user == card.author %}
    <a href="{% url 'edit_card' card.pk %}" class="btn btn-dark ms-3"><i class="bi bi-pencil-fill"></i></a>
{% endif %}
```

Альтернативный вариант. Залогиненные пользователи и те, у которых есть 
разрешение cards.change_card

```html
{% if user.is_authenticated and perms.cards.change_card %}
    <a href="{% url 'edit_card' card.pk %}" class="btn btn-dark ms-3"><i class="bi bi-pencil-fill"></i></a>
{% endif %}
```

**commit: `lesson_69: разрешение на обновление карточек`**

Создали группу модераторов и выдали им права на редактирование карточек.
В шаблон личного кабинете к модераторам добавили BS5 иконку ручки
<i class="bi bi-vector-pen"></i>

```html
{% if user.moderator %}
<i class="bi bi-vector-pen"></i>
{% endif %}
```

Далее, мы НЕ МОЖЕМ вызывать методы с аргументами в шаблонах.
Поэтому, нам надо каким-то образом передать, является ли пользователь модератором или нет в шаблон.
Лучший способ - контекстный процессор. 
Худший - бегать по вьюшкам и передавать это в каждую.
Мы не ищем легких путей

```python
def get_object(self, queryset=None):
        # Возвращает объект модели, который должен быть отредактирован
        # Проверят входит ли пользователь в группу "Модераторы",если да то user.moderator = True
        # Это самая убогая версия, но она работает))
        # Более качественный вариант - контекстный процессор! Он поместит эту проверку во все шаблоны
        user = self.request.user
        if user.groups.filter(name='Модераторы').exists():
            user.moderator = True
        return self.request.user
```
Модифицировали метод get_object в представлении для отображения личного кабинета.
И отрисовали ручку для модераторов в шаблоне личного кабинета.


**commit: `lesson_69: добавил иконку ручки для модераторов в админке (работа с шаблонами)`**

Создаем команду для создания группы модераторов и выдачи прав на редактирование карточек
Создаем для этого в приложении users пакет management/commands и в нем файл create_moderators_group.py


```python
from django.core.management.base import BaseCommand
from django.contrib.auth.models import Group, Permission
from django.contrib.contenttypes.models import ContentType
from your_app_name.models import Card  # Замените 'your_app_name' на имя вашего приложения

class Command(BaseCommand):
    help = 'Создание группы Модераторы и назначение права change_card'

    def handle(self, *args, **kwargs):
        # Создаем или получаем группу "Модераторы"
        moderators_group, created = Group.objects.get_or_create(name='Модераторы')
        
        # Получаем контентный тип для модели Card
        content_type = ContentType.objects.get_for_model(Card)
        
        # Получаем разрешение change_card
        change_card_permission = Permission.objects.get(codename='change_card', content_type=content_type)
        
        # Добавляем разрешение группе "Модераторы"
        moderators_group.permissions.add(change_card_permission)
        
        if created:
            self.stdout.write(self.style.SUCCESS("Группа 'Модераторы' создана и права назначены!"))
        else:
            self.stdout.write(self.style.SUCCESS("Группа 'Модераторы' уже существует и права обновлены!"))

```

Модифицируем команду автодеплоя на севрере timeweb
```bash
python3 manage.py migrate && \
echo "from django.contrib.auth import get_user_model; User = get_user_model(); User.objects.create_superuser('admin', 'ad@ad.com', '12345')" | python3 manage.py shell && \
python3 manage.py loaddata dump.json && \
python3 manage.py create_moderators_group
```

Т.е. все что мы прописали в файле create_moderators_group.py будет выполнено при деплое на сервере
всего одной командой `python3 manage.py create_moderators_group` (по названию файла)


**commit: `lesson_69: создал команду для создания группы модераторов и выдачи прав на редактирование карточек`**


## Lesson 70 - UserPassesTestMixin
UserPassesTestMixin - это миксин, который позволяет проверить, проходит ли пользователь тест, прежде чем получить доступ к представлению.
test_func - это метод, который определяет, проходит ли пользователь тест.

Добавим в представление для редактирования карточки проверку на то, является ли пользователь автором карточки.

```python
    # test_func - метод для миксина UserPassesTestMixin, который проверяет, что пользователь является автором карточки
    def test_func(self):
        card = self.get_object()
        user = self.request.user
        is_moderator = user.groups.filter(name='Модераторы').exists()
        is_administrator = user.is_superuser 
        # is_superuser - это булево поле, которое указывает, является ли пользователь суперпользователем
        # is_staff - это булево поле, которое указывает, имеет ли пользователь доступ к административной панели
        return user == card.author or is_moderator or is_administrator
        
```

Узнали что UserPassesTestMixin и PermissionRequiredMixin - могут конфликтовать друг с другом вне зависимости от порядка их наследования.!!!


Обновили логику в шаблоне card_preview.html
```html
{% if perms.cards.change_card or user == card.author %}
    <a href="{% url 'edit_card' card.pk %}" class="btn btn-dark ms-3"><i class="bi bi-pencil-fill"></i></a>
{% endif %}
```

#TODO - комбинация условий в шаблоне с скобками. Есть ли?

**commit: `lesson_70: добавил проверку на авторство карточки в представление для редактирования карточки`**